<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Anime Character</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --accent-color: #6366F1;
            --accent-color-light: #818CF8;
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #030712;
            font-family: 'Inter', sans-serif;
            cursor: grab;
        }
        body:active { cursor: grabbing; }
        #canvas-container {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1;
        }
        #ui-container {
            position: relative; z-index: 2; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end; height: 100%; width: 100%;
            padding: 1rem 1rem 2rem 1rem;
            background: linear-gradient(to top, rgba(3, 7, 18, 0.95) 15%, rgba(3, 7, 18, 0) 60%);
            pointer-events: none;
        }
        #ui-container > * { pointer-events: auto; }
        #status-wrapper {
            display: flex;
            align-items: center;
            padding: 0.5rem 1.25rem;
            background-color: rgba(17, 24, 39, 0.7);
            color: #d1d5db; border-radius: 9999px; font-size: 0.875rem;
            margin-bottom: 1.5rem; backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .thinking-dots span {
            display: inline-block;
            width: 6px; height: 6px;
            background-color: var(--accent-color-light);
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-container">
        <div id="status-wrapper">
            <span id="status-text">Sahne hazırlanıyor...</span>
            <div id="thinking-indicator" class="thinking-dots ml-2 hidden">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="w-full max-w-2xl">
            <div class="relative">
                <input type="text" id="userInput" placeholder="Ona bir şeyler söyle..." disabled
                    class="w-full py-4 pl-6 pr-20 bg-gray-900/80 border border-gray-700 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all duration-300 backdrop-blur-sm shadow-lg placeholder-gray-500">
                <button id="sendButton" disabled
                    class="absolute inset-y-0 right-0 flex items-center justify-center w-16 h-full text-gray-400 hover:text-indigo-400 transition-colors duration-300 disabled:text-gray-600 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from 'https://esm.sh/@pixiv/three-vrm@2.0.9';

        // ===== CORE SYSTEM CLASSES =====
        class CharacterController {
            constructor(vrm) {
                this.vrm = vrm;
                this.expressions = {
                    happy: 0,
                    sad: 0,
                    mouth: 0
                };
                this.targetExpressions = { ...this.expressions };
                this.animationSpeed = 0.1;
            }

            update(deltaTime) {
                if (!this.vrm?.expressionManager) return;

                // Smooth expression transitions
                Object.keys(this.expressions).forEach(key => {
                    this.expressions[key] = THREE.MathUtils.lerp(
                        this.expressions[key], 
                        this.targetExpressions[key], 
                        this.animationSpeed
                    );
                    
                    this.vrm.expressionManager.setValue(key, this.expressions[key]);
                });

                this.vrm.update(deltaTime);
            }

            setExpression(type, value) {
                if (this.targetExpressions.hasOwnProperty(type)) {
                    this.targetExpressions[type] = value;
                }
            }

            resetExpressions() {
                Object.keys(this.targetExpressions).forEach(key => {
                    this.targetExpressions[key] = 0;
                });
            }
        }

        class AudioManager {
            constructor() {
                this.context = null;
                this.analyser = null;
                this.audioData = null;
                this.currentSource = null;
                this.isInitialized = false;
                this.init();
            }

            async init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.context.createAnalyser();
                    this.analyser.fftSize = 256;
                    this.audioData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.isInitialized = true;
                    console.log('Audio system initialized successfully');
                } catch (error) {
                    console.error('Audio initialization failed:', error);
                }
            }

            async resume() {
                if (this.context && this.context.state === 'suspended') {
                    await this.context.resume();
                }
            }

            getMouthOpenValue() {
                if (!this.analyser || !this.audioData) return 0;
                
                this.analyser.getByteFrequencyData(this.audioData);
                
                // Focus on speech frequencies (85Hz - 255Hz)
                let sum = 0;
                let count = 0;
                for (let i = 3; i < 8; i++) {
                    if (this.audioData[i] > 0) {
                        sum += this.audioData[i];
                        count++;
                    }
                }
                
                if (count === 0) return 0;
                
                const average = sum / count;
                // Map to mouth opening (0.0 - 0.4)
                return Math.min(0.4, (average / 128.0) * 0.5);
            }

            playAudio(audioBuffer) {
                if (!this.context || !this.analyser) return null;

                this.stopCurrentAudio();
                
                const source = this.context.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.analyser);
                this.analyser.connect(this.context.destination);
                
                this.currentSource = source;
                source.start(0);
                
                return source;
            }

            stopCurrentAudio() {
                if (this.currentSource) {
                    this.currentSource.stop();
                    this.currentSource.disconnect();
                    this.currentSource = null;
                }
            }

            cleanup() {
                this.stopCurrentAudio();
                if (this.analyser) {
                    this.analyser.disconnect();
                }
            }
        }

        class SpeechSynthesizer {
            constructor(audioManager) {
                this.audioManager = audioManager;
                this.apiKey = "AIzaSyDVKrvvjIc5dQkiEwpPHYOOzF1TI7ennks";
                this.isSpeaking = false;
                this.speechInterval = null;
            }

            async speak(text) {
                if (!text || text.trim().length < 2) return false;
                
                this.isSpeaking = true;
                
                try {
                    const audioBuffer = await this.generateTTS(text);
                    if (audioBuffer) {
                        const source = this.audioManager.playAudio(audioBuffer);
                        if (source) {
                            source.onended = () => this.onSpeechEnd();
                            return true;
                        }
                    }
                } catch (error) {
                    console.error('TTS failed, using fallback:', error);
                }
                
                // Fallback: simulate speech without audio
                this.simulateSpeech(text);
                return false;
            }

            async generateTTS(text) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${this.apiKey}`;
                
                const payload = {
                    model: "gemini-2.5-flash-preview-tts",
                    contents: [{ parts: [{ text: text }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Leda" }
                            }
                        }
                    }
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`TTS API failed: ${response.status}`);
                }

                const result = await response.json();
                
                if (!result.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
                    throw new Error('Invalid TTS response');
                }

                const audioData = result.candidates[0].content.parts[0].inlineData.data;
                const pcmBuffer = this.base64ToArrayBuffer(audioData);
                const pcmData = new Int16Array(pcmBuffer);
                const wavBuffer = this.pcmToWav(pcmData, 24000);
                
                return await this.audioManager.context.decodeAudioData(wavBuffer);
            }

            simulateSpeech(text) {
                const wordCount = text.split(' ').length;
                const duration = (wordCount / 150) * 60 * 1000; // 150 words per minute
                
                let startTime = Date.now();
                this.speechInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress >= 1) {
                        this.onSpeechEnd();
                        return;
                    }
                    
                    // Simulate mouth movement with sine wave
                    const mouthValue = 0.1 + (Math.sin(progress * Math.PI * 8) * 0.3);
                    // This will be handled by the character controller
                }, 50);
            }

            onSpeechEnd() {
                this.isSpeaking = false;
                if (this.speechInterval) {
                    clearInterval(this.speechInterval);
                    this.speechInterval = null;
                }
            }

            stop() {
                this.isSpeaking = false;
                if (this.speechInterval) {
                    clearInterval(this.speechInterval);
                    this.speechInterval = null;
                }
                this.audioManager.stopCurrentAudio();
            }

            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            pcmToWav(pcmData, sampleRate) {
                const buffer = new ArrayBuffer(44 + pcmData.length * 2);
                const view = new DataView(buffer);
                
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + pcmData.length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, pcmData.length * 2, true);
                
                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(44 + i * 2, pcmData[i], true);
                }
                
                return buffer;
            }
        }

        class AIResponseGenerator {
            constructor() {
                this.apiKey = "AIzaSyDVKrvvjIc5dQkiEwpPHYOOzF1TI7ennks";
            }

            async generateResponse(prompt) {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${this.apiKey}`;
                
                const requestBody = {
                    contents: [{
                        parts: [{
                            text: `Sen sevimli, zeki ve biraz utangaç bir anime karakterisin. Kullanıcının mesajına her zaman en az 3 kelimeden oluşan, sevimli ve kişiliğine uygun kısa bir cümle ile cevap ver. Asla tek kelimelik veya boş cevap verme. Cevabının genel duygusunu da 'happy' veya 'sad' kelimelerinden biriyle belirt. Cevabını JSON formatında şu şekilde ver: {"cevap": "...", "duygu": "..."}. Kullanıcının sözü: "${prompt}"`
                        }]
                    }]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }

                const result = await response.json();
                
                if (!result.candidates?.[0]?.content?.parts?.[0]) {
                    throw new Error('Invalid API response');
                }

                const text = result.candidates[0].content.parts[0].text;
                return JSON.parse(text.replaceAll("```json", "").replaceAll("```", "").trim());
            }
        }

        class SceneManager {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.clock = new THREE.Clock();
                this.controls = null;
                this.particles = null;
                this.vrm = null;
                
                this.init();
            }

            init() {
                // Camera setup
                this.camera.position.set(0.0, 1.3, 2.0);
                
                // Lighting
                this.scene.add(new THREE.AmbientLight(0xffffff, 1.0));
                this.scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 2.0));
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
                directionalLight.position.set(1, 2, 3).normalize();
                this.scene.add(directionalLight);
                
                // Renderer
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                
                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0.0, 1.1, 0.0);
                this.controls.enablePan = false;
                this.controls.minDistance = 1.5;
                this.controls.maxDistance = 3.0;
                this.controls.maxPolarAngle = Math.PI / 2;
                
                // Particles
                this.createParticles();
                
                // Event listeners
                window.addEventListener('resize', () => this.onWindowResize());
            }

            createParticles() {
                const particleCount = 5000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 10;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.PointsMaterial({ size: 0.005, color: 0x6366F1 });
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }

            render() {
                if (this.controls) this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            update(deltaTime) {
                if (this.particles) {
                    this.particles.rotation.y += deltaTime * 0.02;
                }
            }
        }

        // ===== MAIN APPLICATION CLASS =====
        class AIAnimeCharacter {
            constructor() {
                this.state = 'loading';
                this.sceneManager = null;
                this.characterController = null;
                this.audioManager = null;
                this.speechSynthesizer = null;
                this.aiGenerator = null;
                this.modelUrl = 'https://mustafaincby44.github.io/A-_AnimeGirl/public/AIAnimeGirl.vrm';
                this.fallbackModelUrl = 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
                
                this.init();
            }

            async init() {
                try {
                    // Initialize core systems
                    this.sceneManager = new SceneManager(document.getElementById('canvas-container'));
                    this.audioManager = new AudioManager();
                    this.speechSynthesizer = new SpeechSynthesizer(this.audioManager);
                    this.aiGenerator = new AIResponseGenerator();
                    
                    // Load 3D model
                    await this.loadModel();
                    
                    // Start animation loop
                    this.animate();
                    
                    // Setup UI
                    this.setupUI();
                    
                    this.setState('idle');
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.setState('error');
                }
            }

            async loadModel() {
                const loader = new GLTFLoader();
                loader.register((parser) => new VRMLoaderPlugin(parser));
                
                return new Promise((resolve, reject) => {
                    loader.load(this.modelUrl,
                        (gltf) => {
                            if (this.sceneManager.vrm) {
                                this.sceneManager.scene.remove(this.sceneManager.vrm.scene);
                            }
                            
                            this.sceneManager.vrm = gltf.userData.vrm;
                            VRMUtils.rotateVRM0(this.sceneManager.vrm);
                            this.sceneManager.scene.add(this.sceneManager.vrm.scene);
                            
                            // Initialize character controller
                            this.characterController = new CharacterController(this.sceneManager.vrm);
                            
                            resolve();
                        },
                        (progress) => {
                            const percent = Math.round((progress.loaded / progress.total) * 100);
                            this.updateStatus(`Model indiriliyor... ${percent}%`);
                        },
                        (error) => {
                            console.error('Model loading failed:', error);
                            if (this.modelUrl !== this.fallbackModelUrl) {
                                this.modelUrl = this.fallbackModelUrl;
                                this.loadModel().then(resolve).catch(reject);
                            } else {
                                reject(error);
                            }
                        }
                    );
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const deltaTime = this.sceneManager.clock.getDelta();
                
                // Update scene
                this.sceneManager.update(deltaTime);
                
                // Update character
                if (this.characterController) {
                    // Handle mouth animation based on speech state
                    if (this.state === 'speaking') {
                        if (this.speechSynthesizer.isSpeaking) {
                            const mouthValue = this.audioManager.getMouthOpenValue();
                            this.characterController.setExpression('mouth', mouthValue);
                        }
                    } else {
                        this.characterController.setExpression('mouth', 0);
                    }
                    
                    this.characterController.update(deltaTime);
                }
                
                // Render
                this.sceneManager.render();
            }

            setupUI() {
                this.statusText = document.getElementById('status-text');
                this.thinkingIndicator = document.getElementById('thinking-indicator');
                this.userInput = document.getElementById('userInput');
                this.sendButton = document.getElementById('sendButton');
                
                this.sendButton.addEventListener('click', () => this.handleUserInput());
                this.userInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter') this.handleUserInput();
                });
            }

            async handleUserInput() {
                const text = this.userInput.value.trim();
                if (!text || this.state === 'thinking' || this.state === 'speaking') return;
                
                this.userInput.value = '';
                this.setState('thinking');
                
                try {
                    // Get AI response
                    const response = await this.aiGenerator.generateResponse(text);
                    
                    // Set emotion
                    if (this.characterController) {
                        this.characterController.resetExpressions();
                        if (response.duygu === 'happy') {
                            this.characterController.setExpression('happy', 1.0);
                        } else if (response.duygu === 'sad') {
                            this.characterController.setExpression('sad', 1.0);
                        }
                    }
                    
                    // Speak response
                    this.setState('speaking');
                    await this.speechSynthesizer.speak(response.cevap);
                    
                } catch (error) {
                    console.error('Interaction failed:', error);
                    this.setState('error');
                    setTimeout(() => this.setState('idle'), 2000);
                }
            }

            setState(newState) {
                this.state = newState;
                
                switch (newState) {
                    case 'loading':
                        this.updateStatus('Sahne hazırlanıyor...');
                        this.enableUI(false);
                        break;
                    case 'idle':
                        this.updateStatus('Sıradaki mesajını bekliyorum.');
                        this.enableUI(true);
                        this.speechSynthesizer.stop();
                        break;
                    case 'thinking':
                        this.updateStatus('Düşünüyor...', true);
                        this.enableUI(false);
                        break;
                    case 'speaking':
                        this.updateStatus('Konuşuyor...');
                        this.enableUI(false);
                        break;
                    case 'error':
                        this.updateStatus('Bir hata oluştu.');
                        this.enableUI(true);
                        break;
                }
            }

            updateStatus(text, isThinking = false) {
                if (this.statusText) this.statusText.textContent = text;
                if (this.thinkingIndicator) {
                    this.thinkingIndicator.classList.toggle('hidden', !isThinking);
                }
            }

            enableUI(isEnabled) {
                if (this.userInput) this.userInput.disabled = !isEnabled;
                if (this.sendButton) this.sendButton.disabled = !isEnabled;
            }
        }

        // ===== APPLICATION STARTUP =====
        let app = null;
        
        window.addEventListener('DOMContentLoaded', () => {
            app = new AIAnimeCharacter();
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (app?.speechSynthesizer) {
                app.speechSynthesizer.stop();
            }
            if (app?.audioManager) {
                app.audioManager.cleanup();
            }
        });
    </script>
</body>
</html>
