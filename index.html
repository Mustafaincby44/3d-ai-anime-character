<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D AI Anime chatbot </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --accent-color: #6366F1; /* Indigo-500 */
            --accent-color-light: #818CF8; /* Indigo-400 */
        }
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #030712; /* Gray-950 */
            font-family: 'Inter', sans-serif;
            cursor: grab;
        }
        body:active { cursor: grabbing; }
        #canvas-container {
            width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1;
        }
        #ui-container {
            position: relative; z-index: 2; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end; height: 100%; width: 100%;
            padding: 1rem 1rem 2rem 1rem;
            background: linear-gradient(to top, rgba(3, 7, 18, 0.95) 15%, rgba(3, 7, 18, 0) 60%);
            pointer-events: none;
        }
        #ui-container > * { pointer-events: auto; }
        #status-wrapper {
            display: flex;
            align-items: center;
            padding: 0.5rem 1.25rem;
            background-color: rgba(17, 24, 39, 0.7); /* Gray-900 with transparency */
            color: #d1d5db; border-radius: 9999px; font-size: 0.875rem;
            margin-bottom: 1.5rem; backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .thinking-dots span {
            display: inline-block;
            width: 6px; height: 6px;
            background-color: var(--accent-color-light);
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-container">
        <div id="status-wrapper">
            <span id="status-text">Sahne hazırlanıyor...</span>
            <div id="thinking-indicator" class="thinking-dots ml-2 hidden">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="w-full max-w-2xl">
            <div class="relative">
                <input type="text" id="userInput" placeholder="Ona bir şeyler söyle..." disabled
                    class="w-full py-4 pl-6 pr-20 bg-gray-900/80 border border-gray-700 text-white rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all duration-300 backdrop-blur-sm shadow-lg placeholder-gray-500">
                <button id="sendButton" disabled
                    class="absolute inset-y-0 right-0 flex items-center justify-center w-16 h-full text-gray-400 hover:text-indigo-400 transition-colors duration-300 disabled:text-gray-600 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from 'https://esm.sh/@pixiv/three-vrm@2.0.9';

        // --- UI Elements ---
        const statusText = document.getElementById('status-text');
        const thinkingIndicator = document.getElementById('thinking-indicator');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const container = document.getElementById('canvas-container');
        
        // --- State Management ---
        let state = 'loading'; // loading, idle, thinking, speaking
        
        // --- 3D Scene Variables ---
        let camera, scene, renderer, clock, vrm, controls;
        let particles;

        // --- Audio Variables ---
        let audioContext;
        let analyser = null;
        let audioDataArray;
        let currentAudioSource = null;
        
        // --- Mouth Animation Variables ---
        let targetMouthOpen = 0.0;
        let currentMouthOpen = 0.0;
        let mouthAnimationSpeed = 0.15;

        // --- Model URLs ---
        const userModelUrl = 'https://mustafaincby44.github.io/A-_AnimeGirl/public/AIAnimeGirl.vrm';
        const fallbackModelUrl = 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm';
        
        init();

        function init() {
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.error('Web Audio API is not supported in this browser');
            }

            camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(0.0, 1.3, 2.0);

            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            scene.add(new THREE.HemisphereLight(0xffffbb, 0x080820, 2.0));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(1, 2, 3).normalize();
            scene.add(directionalLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0.0, 1.1, 0.0);
            controls.enablePan = false;
            controls.minDistance = 1.5;
            controls.maxDistance = 3.0;
            controls.maxPolarAngle = Math.PI / 2;

            const particleCount = 5000;
            const particlesGeometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            for(let i = 0; i < particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 10;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particleMaterial = new THREE.PointsMaterial({ size: 0.005, color: 0x6366F1 });
            particles = new THREE.Points(particlesGeometry, particleMaterial);
            scene.add(particles);

            loadModel(userModelUrl);
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function loadModel(url, isFallback = false) {
            setState(isFallback ? 'loading_fallback' : 'loading');
            
            const loader = new GLTFLoader();
            loader.register((parser) => new VRMLoaderPlugin(parser));

            loader.load(url,
                (gltf) => {
                    if (vrm) scene.remove(vrm.scene);
                    vrm = gltf.userData.vrm;
                    VRMUtils.rotateVRM0(vrm);
                    scene.add(vrm.scene);
                    setState('idle');
                },
                (progress) => {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    updateStatus(`Model indiriliyor... ${percent}%`);
                },
                (error) => {
                    console.error('Model yüklenirken hata oluştu:', url, error);
                    if (!isFallback) {
                        loadModel(fallbackModelUrl, true);
                    } else {
                        setState('error');
                    }
                }
            );
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            particles.rotation.y += delta * 0.02;

            if (vrm && vrm.expressionManager) {
                vrm.update(delta);

                // Ağız animasyonu sadece konuşma sırasında
                if (state === 'speaking' && analyser) {
                    // Ses analizi
                    analyser.getByteFrequencyData(audioDataArray);
                    
                    // Konuşma frekanslarını analiz et
                    let sum = 0;
                    let count = 0;
                    for (let i = 3; i < 8; i++) {
                        if (audioDataArray[i] > 0) {
                            sum += audioDataArray[i];
                            count++;
                        }
                    }
                    
                    if (count > 0) {
                        const average = sum / count;
                        // Ağız açılımı 0.4 ile 0 arasında
                        targetMouthOpen = Math.min(0.4, (average / 128.0) * 0.6);
                    } else {
                        targetMouthOpen = 0.0;
                    }
                } else {
                    // Konuşma dışında ağız kapalı
                    targetMouthOpen = 0.0;
                }
                
                // Yumuşak ağız animasyonu
                currentMouthOpen = THREE.MathUtils.lerp(currentMouthOpen, targetMouthOpen, mouthAnimationSpeed);
                
                // Ağız ifadesini güncelle
                vrm.expressionManager.setValue('aa', currentMouthOpen);
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        async function handleInteraction() {
            if (audioContext.state === 'suspended') await audioContext.resume();
            
            const userText = userInput.value.trim();
            if (!userText || state === 'thinking' || state === 'speaking') return;

            stopCurrentSpeech();
            userInput.value = '';
            setState('thinking');

            try {
                const aiResponse = await getAIResponse(userText);
                setEmotion(aiResponse.duygu);
                speak(aiResponse.cevap);
            } catch (error) {
                console.error("API Hatası:", error);
                speak("Üzgünüm, bir sorunla karşılaştım.");
            }
        }

        async function getAIResponse(prompt) {
            const apiKey = "AIzaSyDVKrvvjIc5dQkiEwpPHYOOzF1TI7ennks";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const requestBody = {
                contents: [{ parts: [{ text: `Sen sevimli, zeki ve biraz utangaç bir anime karakterisin. Kullanıcının mesajına her zaman en az 3 kelimeden oluşan, sevimli ve kişiliğine uygun kısa bir cümle ile cevap ver. Asla tek kelimelik veya boş cevap verme. Cevabının genel duygusunu da 'happy' veya 'sad' kelimelerinden biriyle belirt. Cevabını JSON formatında şu şekilde ver: {"cevap": "...", "duygu": "..."}. Kullanıcının sözü: "${prompt}"` }] }]
            };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
            if (!response.ok) throw new Error(`API isteği başarısız: ${response.status}`);
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]) {
               const text = result.candidates[0].content.parts[0].text;
               return JSON.parse(text.replaceAll("```json", "").replaceAll("```", "").trim());
            }
            throw new Error("API'den beklenmedik veya boş cevap alındı.");
        }

        async function speak(text) {
            if (!text || text.trim().length < 2) {
                setState('idle');
                updateStatus('Ne diyeceğimi bilemedim...');
                setEmotion('sad');
                setTimeout(() => {
                    if (state === 'idle') {
                         updateStatus('Sıradaki mesajını bekliyorum.');
                    }
                }, 2000);
                return;
            }
            
            try {
                const apiKey = "AIzaSyDVKrvvjIc5dQkiEwpPHYOOzF1TI7ennks";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                const payload = { 
                    model: "gemini-2.5-flash-preview-tts", 
                    contents: [{ parts: [{ text: text }] }], 
                    generationConfig: { 
                        responseModalities: ["AUDIO"], 
                        speechConfig: { 
                            voiceConfig: { 
                                prebuiltVoiceConfig: { voiceName: "Leda" } 
                            } 
                        } 
                    } 
                };
                
                const response = await fetch(apiUrl, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(payload) 
                });
                
                if (!response.ok) throw new Error(`TTS API isteği başarısız: ${response.status}`);
                const result = await response.json();
                
                if (!result.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
                    const finishReason = result.candidates?.[0]?.finishReason;
                    console.error(`TTS Yanıtı Hatalı. Sebep: ${finishReason || 'Bilinmiyor'}`, JSON.stringify(result, null, 2));
                    throw new Error("TTS API'sinden geçersiz veya hatalı yanıt alındı.");
                }

                const audioPart = result.candidates[0].content.parts[0];
                const audioData = audioPart.inlineData.data;
                const pcmBuffer = base64ToArrayBuffer(audioData);
                const pcmData = new Int16Array(pcmBuffer);
                const wavBuffer = pcmToWav(pcmData, 24000);
                const audioBuffer = await audioContext.decodeAudioData(wavBuffer);
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                currentAudioSource = source;

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                audioDataArray = new Uint8Array(analyser.frequencyBinCount);
                
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                setState('speaking');
                source.start(0);

                source.onended = () => {
                    // Konuşma bittiğinde ağızı kapat
                    targetMouthOpen = 0.0;
                    currentMouthOpen = 0.0;
                    if (vrm?.expressionManager) {
                        vrm.expressionManager.setValue('aa', 0);
                    }
                    setState('idle');
                };
            } catch (error) {
                console.error("TTS Hatası:", error);
                setState('error');
            }
        }
        
        function stopCurrentSpeech() {
            if (currentAudioSource) {
                currentAudioSource.onended = null;
                currentAudioSource.stop();
                currentAudioSource.disconnect();
                currentAudioSource = null;
            }
            analyser = null;
            // Ağız animasyonunu sıfırla
            targetMouthOpen = 0.0;
            currentMouthOpen = 0.0;
        }

        function setState(newState) {
            state = newState;
            switch(state) {
                case 'loading':
                    updateStatus('Sahne hazırlanıyor...');
                    enableUI(false);
                    break;
                case 'loading_fallback':
                    updateStatus('Varsayılan model yükleniyor...');
                    enableUI(false);
                    break;
                case 'idle':
                    updateStatus('Sıradaki mesajını bekliyorum.');
                    enableUI(true);
                    setEmotion('neutral');
                    stopCurrentSpeech();
                    break;
                case 'thinking':
                    updateStatus('Düşünüyor...', true);
                    enableUI(false);
                    // Düşünme sırasında ağızı kapat
                    targetMouthOpen = 0.0;
                    currentMouthOpen = 0.0;
                    if (vrm?.expressionManager) {
                        vrm.expressionManager.setValue('aa', 0);
                    }
                    break;
                case 'speaking':
                    updateStatus('Konuşuyor...');
                    enableUI(false);
                    break;
                case 'error':
                    updateStatus('Bir hata oluştu.');
                    enableUI(true);
                    break;
            }
        }

        function updateStatus(text, isThinking = false) {
            statusText.textContent = text;
            thinkingIndicator.classList.toggle('hidden', !isThinking);
        }

        function enableUI(isEnabled) {
            userInput.disabled = !isEnabled;
            sendButton.disabled = !isEnabled;
        }

        function setEmotion(emotion) {
            if (!vrm?.expressionManager) return;
            vrm.expressionManager.setValue('happy', 0);
            vrm.expressionManager.setValue('sad', 0);
            if (emotion === 'happy') vrm.expressionManager.setValue('happy', 1.0);
            if (emotion === 'sad') vrm.expressionManager.setValue('sad', 1.0);
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }
            return buffer;
        }

        sendButton.addEventListener('click', handleInteraction);
        userInput.addEventListener('keydown', (event) => { if (event.key === 'Enter') handleInteraction(); });
    </script>
</body>
</html>
